En el waveplayer se encuentra el PLAY_REPEAT_DISABLED
que es la funcion que detiene el loop en el main.h

en waveplayer:

#ifdef PLAY_REPEAT_DISABLED 
  RepeatState = REPEAT_OFF;
  /* Stop playing Wave */
  WavePlayerStop();
  /* Close file */
  f_close(&FileRead);
  /* Test on the command: Playing */
  if(CmdIndex == CMD_PLAY)
  {
    LEDsState = LED4_TOGGLE; //este es el led
que se enciende cuando esta a la espera de 
una nueva grabación. Y se pone en CMD_PLAY??
  }

En el main.h están definidas tres variables
#define CMD_PLAY           ((uint32_t)0x00)
#define CMD_RECORD         ((uint32_t)0x01)
#define CMD_STOP           ((uint32_t)0x02)

VOLVIENDO AL MAIN.C

Cuando presiono el boton para grabar 
comienza la funcion de grabacion y Cmd_Index
toma el valor de CMD_RECORD. 
Luego vuelvo a presionar y corta la grabacion
y pasa automaticamente a la reproducción.


********************************************

Encontre donde utilizaba la variable en estado 
CMD_STOP:

 if (CmdIndex != CMD_RECORD)//acá tengo que modificar algo? //creo que acá es donde con el pulsador se modifica el valor de la variable CmdIndex
      {
        /* Stop Audio Recording */
        WaveRecorderStop();
        /* Switch Command Index to Play */
        CmdIndex = CMD_PLAY;//ACA CAMBIA EL ESTADO DE GRABACION AL DE PLAY QUE DESP USA EL MAIN.C linea 223
        /* Toggoling LED6 to signal Play */
        LEDsState = LED6_TOGGLE; //se enciende el led azul cuando se pone en play
        break;
      }
    }
    else /* End of recording time TIME_REC *///si esta es la opcion para cuando se terminan los segundos para grabar y "hace lo mismo que si para al agrabacion el usuario" por qué pasa a cmdIndex=CMD_STOP y no CMD_PLAY?
    {
      /* Stop Audio Recording */
      WaveRecorderStop();
      /* Change Command Index to Stop */
      CmdIndex = CMD_STOP;
      /* Toggoling LED4 to signal Stop */
      LEDsState = LED4_TOGGLE; //este es el led que se enciende cuando está a la espera de una nueva grabación
      AUDIODataReady = 0;
      break;
    }

**********************************************
2-09-22
Agregué al main.c lineas de case para probar el 
estado de CmdIndex=CMD_STOP de la siguiente manera:

static void COMMAND_AudioExecuteApplication(void)
{
  /* Execute the command switch the command index */
  switch (CmdIndex)
  {
    /* Start Playing from USB Flash memory */
  case CMD_PLAY:
    if (RepeatState == REPEAT_ON)
      WavePlayerStart();
    break;
    
    /*Agrego estas lineas para probar si se detiene cuando termino de grabar*/
  case CMD_STOP:
	  RepeatState = REPEAT_ON;//estaría bien porque después de que se detenga quiero que vuelva a reproducir
	  WaveRecorderStop();//creo que esto no va porque ya se lo detiene con CmdIndex!=CMD_RECORD
	  WavePlayerStop();
	  
	  break;
	  
    /* Start Recording in USB Flash memory */ 
  case CMD_RECORD:
    RepeatState = REPEAT_ON;//es como si esta variable fuese la conexion entre el CMD_PLAY
    WaveRecorderProcess();
    break;
  
  default:
    break;
  }
}

Así no modifica nada, por eso voy a ver los otros archivos
y tambien deberia ver la interaccion entre placa y
ususario alla por la linea 463 del main.c

Cambié la linea 180 de waverecorder.c
CmdIndex= CMD_STOP;
Cambié la linea 182 de waverecorder.c
LEDsState = LED4_TOGGLE; esto es lo que hace que cambie

Habiendo hecho todo esto, sigue haciendo lo mismo. Lo
unico que cambia es que entra el estado de la 
linea 182 del waverecorder.c pero por muy poco tiempo
No se llega a notar que para y tampoco se mantiene
en ese estado (led verde)
Voy a dejar el codigo como está y seguir probando cosas.

No me peguen pero agregué un Hal_Delay en waverecorder.c
en 183 para ver si se quedaba un rato más ahí

no hizo nada

Cambié la linea 476 de main.c
CmdIndex = CMD_STOP;
antes era CMD_PLAY

pruebo

hace lo mismo

cambio 473 RepeatState=REPEAT_OFF; en main.c

pruebo 

SE PASA AL ESTADO DE PAUSA!!
Pero ahora no pasa al estado de reproducir jajajja
Aveeerrr

desp de un tiempo si paso.... raro
lo hizo una sola vez... más raro

Claramente estan relacionadas las de CmdIndex y 
RepeatState
como? no sé. Lo averiguaremos.

cambie linea 236 de main.c
de repaet on a repeat_off
y voy a volver a como estaba la lina 473 a repeat on

pruebo

vuelve a hacer lo que hacia antes de quedarse en el stop

Así que vuelvo a como había logrado que se quede en stop

cambie la linea 484 de main.c
el else lo transforme a else if 

    else if (CmdIndex == CMD_STOP)

pruebo

se sigue quedando trabado en el led verde

Voy a volver a poner la linea 476 en CMD_PLAY;

pruebo

no cambia

comente todo lo que había escrito hoy como CASE
en el main.c

pruebo

hace lo mismo que antes
lo que me di cuenta es que cuando lo dejo grabando el
tiempo maximo de grabacion que son 30 seg
sigue haciendo lo que hacia antes de reproducir 
directamente lo que grabo, sin pasar por el estado de stop

Hay una parte del waverecorder.c que le dice que cuando
llega el timeout haga algo... pero lo que le dice es:

else /* End of recording time TIME_REC */
    {
      /* Stop Audio Recording */
      WaveRecorderStop();
      /* Change Command Index to Stop */
      CmdIndex = CMD_STOP;
      /* Toggoling LED4 to signal Stop */
      LEDsState = LED4_TOGGLE; //este es el led que se enciende cuando está a la espera de una nueva grabación
      AUDIODataReady = 0;
      break;

lo unico que hace es ir a waveRecorderStop
Desp va a la posicion de STOP a la espera de una nueva
grabación
Por eso voy a la funcion de WaveRecorderStop
que me lleva a BSP_AUDIO_IN_Stop

volvi a cambiar la linea 180 de waverecorder.c
para ver si igualmente se queda en stop cuando termino
de grabar (CmdIndex = CMD_PLAY)

pruebo

Efectivamente se queda en el stop así que lo dejo así

Voy a leer el waveplayer por las dudas

paro acá porq ya me quemé

********************************************************
5-10-22

Volviendo a lo que quería hacer.
Necesito que al presionar el boton de grabar, comience a grabar.
Luego al volver a presionarlo, tiene que pasar al modo STOP.
y cuando vuelva a apretarlo debe pasaar al modo reproducción.

Que reproduzca todo.

Una vez controlado todo lo anterior, lo ideal sería que
en el medio de la repoducción tambien lo pueda parar 
cuando quiera pero sin volver a entrar al modo grabacion.

Eso es todo, desp lo replico para la botonera matricial.

Aún no encontré la relacion entre la variable CmdIndex y RepeatState

Creo que ahí está la clave para hacer todo lo que quiero
Tal vez tenga que crear un estado intermedio para
que cuando pare la grabación no me cierre la carpeta
donde está la grabación. Porque sino desp como la reanudo?

Por lo que dice en el ifdef del waveplayer...

Pero voy a volver a revisar todo el codigo desde main, porque siento que
me pierdo cuando entro a un archivo de waveplayer o waverecorder sin 
saber como o desde donde fueron invocadas.

Lo que veo en los archivos de waveplayer es que cuando ejecuta
la funcion de por ejemplo, WavePlayerStop, entra a una función
que ejecuta el BSP_AUDIO_OUT_Stop. Pero dentro de esa
función, no toca los valores ni de CmdIndex ni de RepeatSatate.
Osea, lo de antes de nuevo. Voy a volver al main y ver que onda


Fijarme en el main.c si puedo cambiar el GPIO para que pase 
a hacer otra cosa en lugar de solo grabar y parar.
Creo que hay distintos tipos como AUDIO_STATE_blah blah 
En el video que encontre, el chabon modifica la variable
que había declarado como index
Osea que en relacion a mi programa, la variable 
que se cambia es la CmdIndex.

Tal vez tenga que integrar una funcion al main que 
utilice una de las funciones del CmdIndex que sea
el pause o stop. Algun HAL_GPIO_EXIT_Callback...?

---------------------------------------------------------------------------------

6-10-22

En el waveplayer.c dice que la variable CmdIndex está hecha para controlar
el pllay, record o stop. La usa como variable externa que se declara en 
main.c

En realidad están relacionadas 4 variables
CmdIndex // está en play, record o stop
PressCount //cuenta la cantidad de veces que se presiona el boton
PauseResumeStatus // no se que hace -Wave Player Pause/Resume Status
RepeatState //repeat_on o repeat_off

todas estan declaradas en el main.c pero se usan como externas en el waveplayer.c


/* Defines for the Audio playing process */
#define PAUSE_STATUS     ((uint32_t)0x00) /* Audio Player in Pause Status */
#define RESUME_STATUS    ((uint32_t)0x01) /* Audio Player in Resume Status */
#define IDLE_STATUS      ((uint32_t)0x02) /* Audio Player in Idle Status */

#define REPEAT_ON        ((uint32_t)0x00) /* Replay Status in ON */
#define REPEAT_OFF       ((uint32_t)0x01) /* Replay Status in OFF */

367 de stm32f4_discovery_audio.c
     HAL_GPIO_WritePin(AUDIO_RESET_GPIO, AUDIO_RESET_PIN, GPIO_PIN_RESET);

----------------------------------------------------------------------------------
31-10-22

Holis

En el waveplayer.c linea 307, no debería estar el CmdIndex en CMD_STOP?
Digo porque esta leyendo y dice que si 


Tener en cuenta esta funcion para otras opciones más adelante si no funciona
lo que quiero hacer:

void WavePlayer_CallBack(void)
{
  if(AppliState != APPLICATION_IDLE)
  {
    /* Reset the Wave player variables */
    RepeatState = REPEAT_ON;
    AudioPlayStart = 0;
    LEDsState = LEDS_OFF;
    PauseResumeStatus = RESUME_STATUS;
    WaveDataLength =0;
    PressCount = 0;
    
    /* Stop the Codec */
    if(BSP_AUDIO_OUT_Stop(CODEC_PDWN_HW) != AUDIO_OK)
    {
      Error_Handler();
    }
    
    /* Turn OFF LED3, LED4 and LED6 */
    BSP_LED_Off(LED3);
    BSP_LED_Off(LED4);
    BSP_LED_Off(LED6);
  }

Está en el waveplayer.c linea 328

Lo que veo es quee cuando entra a un case o alguna funcion, prepara
las variables que vimos antes pero para el proximo estado.
Por eso lo que quería probar era modificar los siguientes estados
y agregar en el case del main.c la opcion de pausa.
Es un bardo hacer eso. Por eso anoté la opcion anterior.
Voy a buscar otras cosas por las dudas y desp hago eso.

/**
  * @brief  Stops playing Wave.
  * @param  None
  * @retval None
  */
void WavePlayerStop(void)
{ 
  BSP_AUDIO_OUT_Stop(CODEC_PDWN_HW);
}

linea 213 de waveplayer.c

OK
CONECTE LA PLACA 
lo que sucede ahora es que aprieto una vez y empieza a grabar
Vuelvo a apretar y se va a la pausa directamente
Vuelvo a apretar y vuelve a grabar
Cuando uso el botón solo me permite ir a l estado de grabación.
Ahora, si dejo grabando los 30 segundos, una vez terminado ese tiempo
Pasa a la repoducción automática y se escucha. Desp pasa al estado
de espera de nuevo.

Lo único que logré hasta ahora con:

{cambio 473 RepeatState=REPEAT_OFF; en main.c}

Fue ir al estado de pausa desp de grabar
Pero falta que de ese estado pueda pasar a la reproducción

Que hacemo??

PORQUE ADEMAS EN QUE MOMENTO ENTRA A LA FUNCION DONDE ESTÁ ESA LINEA 
EN EL HAL_GPIO_EXTI_Callback????

Solo para probar algo distinto, vuelvo a poner en ON la linea 473 del main.c

Ahora está todo como antes

Cambio 476 CmdIndex = CMD_PLAY; del main.c
A STOP y en el else if de 484 cambio RepeatState a OFF de 486
y el CmdIndex de 488 lo dejo en PLAY.

A verrrr

Pruebo

Nada, igual que siempre.

Con esos cambios le agrego el de la linea 473 de REPEAT_OFF de nuevo
para ver si de esa manera cuando para de grabar pasa a la pausa y desp
a play...

Pruebo

Noup, se queda en lo mismo de grabar para grabar para, nunca reproduce

Entonces vuelvo a dejar todo como estaba antes porque a pesar
de que pase al estado de pausa desp de grabar, no sé en
que momento entra a esa bendita funcion de Hal gpio exti callbck
Y para meter mano donde no se que pasa, pues no gracias.
//Lo que pasaba es que el HAL_GPIO_EXTI_Callback es una interrupción
y No entraba en reproducción porque en la linea 473, el RepeatState
tomaba el valor de Repeat_Off que no permitia entrar al if de PLAY
de COMMAND_AudioExecuteApplication(void). De nada.


Por lo que vi lo que voy a hacer es crear un nuevo estado en el case del 
main.c y luego entrar tanto al waverecorder.c como al 
waveplayer.c para que tengan en cuenta las modificaciones para el 
nuevo estado del programa ppal y probar.

Entonces, {graba - pausa - reproduce - pausa}
MAIN.C

Agrego en el switch del COMMAND_AudioExecuteApplication el caso
para el cual se puede dar que CmdIndex esté en CMD_STOP.

case CMD_STOP:
	if (RepeatState == REPEAT_OFF)//gancho entre los otros dos estados para poder entrar
		{if (AudioPlayStart==1){
		WavePlayerStop();
		//RepeatState=REPEAT_ON?}//no es necesario creo
		
		
		elseif (WaveRecStatus == 1){
		WaveRecorderStop();
		//RepeatState=REPEAT_ON;}//para que de verdadero el if de CMD_PLAY
		}
break;


Para el primer if utilizo una condicion que sea para ambos estados (grabar
y reproducir) porque la pausa sería un estado consecutivo de ambos.
Para el segundo if tengo que buscar una condición que cumpla solo
una o la otra. Para player puede ser AudioPlayStart=1, y para el
recorder puede ser WaveRecStatus=1.
Para que en el main.c pueda leer esas variables las tengo que declarar
como:
extern uint32_t WaveRecStatus;
extern uint32_t AudioPlayStart;

Por último tengo que preparar el estado CmdIndex para el proximo estado, pero
dentro de waverecorder y waveplayer respectivamente.
Por ejempo linea 180 en waverecorder.c --->CMD_STOP;
y creo que tambien la ultima linea de la funcion de grabacion:
L211--->  CmdIndex = CMD_PLAY; a CMD_STOP;
!El waverecorder no utiliza la variable global RepeatState!
Por eso la setes en el case del main.c, en este caso la modificaría a
REPEAT_OFF;(L243 main.c)

Para el main.c tal vez hacer lo mismo pero utilizando la variable del Repeat.

Tal vez también tenga que cambiar la linea 476 y ...
Aunque no sepa en que momento entra a esa función, que por lo que huelo no
es que entre a la función sino que de alguna exttraña manera entra en el
recorrido de la lectura del código, en fin, voy a tener que modificar 
también HAL_GPIO_EXTI_Callback.

L476---> CmdIndex = CMD_STOP;
L482---> CmdIndex = CMD_STOP;
L488---> if (AudioPlayStart==1){ CmdIndex = CMD_RECORD} elseif (WaveRecStatus == 1) {CmdIndex = CMD_PLAY;}


Que onda con esto?

if(GPIO_Pin == GPIO_PIN_1) 
  {
    if (PressCount == 1)//si es la segunda vez que se aprieta sería?
    {
      /* Resume playing Wave status */
      PauseResumeStatus = RESUME_STATUS;
      PressCount = 0;
    }
    else
    {
      /* Pause playing Wave status */
      PauseResumeStatus = PAUSE_STATUS;
      PressCount = 1;
    }
  }

----------------------------------------------------------------------------
1/11/22

Holiwiiiiiis, hemos vuelto. En el capitulo de hoy, COMO HACER EXPLOTAR TU CEREBRO :)

Esuve anotando un monton de cosas en los apuntes de ayer.
Pero voy a escribir acá para no marearme...más.

Dentro del waverecorder tengo que especificar el cmd_index en STOP para que 
despues me entre al case de STOP del main.c
Pero además tengo que poner cmd_index en PLAY una vez que entre a la 
subfuncion de WaveRecorderStop, para que una vez que se haya pausado
pueda ir al estado de play y no se quede ahí.

L106*--- CmdIndex=CMD_PLAY; //linea nueva;

Ahora hago el recorrido de CMD_STOP luego de haber pausado la grabacion
y pasar a CMD PLAY.

Tendría que agregar al case de PLAY un:
RepeatState = REPEAT_OFF; Para que entre al primer if de STOP.

Dentro del waveplayer.c creo que debería cambiar la L307 a CmdIndex=CMD_STOP;
y dentro de la función WavePlayBack también, pero en realidad nunca la modifica
porque como la unica condicion para que no entre al play 
es la del IF de repeat ON, entonces solo modifica esa variable.
Entonces tendría que agregarle al final una linea modificando el CmdIndex a STOP
para que entre al Stop.

En el case del main.c para PLAY debería agregarle que esté en Repeat off
para que entre al if del case de STOP.


desp en mi case de STOP debería agregarle
//CmdIndex=CMD_RECORD;
o como hice para el caso anterior, agregarle a la función WavePlayerStop

un L220* ---CmdIndex=CMD_RECORD;

*******************************************************************************

4-11-22

Hoy evitaremos preguntas como: Que estoy haciendo? y Por qué elegí esto?

A continuación, un resumen de todas las modificaciones que haríamos:

MAIN.C
agrego:

case CMD_STOP:
	if (RepeatState == REPEAT_OFF)//gancho entre los otros dos estados para poder entrar
		{if (AudioPlayStart==1){
		WavePlayerStop();}
		//RepeatState=REPEAT_OFF?}//no es necesario creo
		
		
		elseif (WaveRecStatus == 1){
		WaveRecorderStop();
		RepeatState=REPEAT_ON;}//para que de verdadero el if de CMD_PLAY
		}
break;

Modifico:
L491--->CMD_PLAY --->CMD_STOP;
L488--->RepeatState=REPEAT_ON --->REPEAT_OFF;
L497--->CMD_RECORD--->CMD_STOP;

Comenté:
L499-L504

Agregué:
L36 ---> extern uint8_t WaveRecStatus;

De esta manera la primera vez: graba, pausa, reproduce, pausa.
Pero después, solo entra al estado de grabación. Además sigue pasando
de que si despues de los 30 seg de grabación no se apreta el botón,
pasa automaticamente a reproducir.
Y cuando reproduzco lo que grabé la primera vez y lo pongo en pausa,
pasa directo a grabar. Como si nunca entrara al STOP que viene del
estado previo de PLAY.

me fui a dormir, chau. 

Igual volví a dejar todo como estaba antes por las dudas :3

Probar comentar linea 188 de waveplayer.c
presscount tal vez se pueda utilizar como variable para
evaluar si el estado anterior era el de reproducción.

Nuevo posible case

case CMD_STOP:
	if (RepeatState==REPEAT_ON) 
	{
	WaveRecorderStop();
	RepeatState=on
	CmdIndex=CMD_PLAY;
	}

	else if (RepeatState==REPEAT_OFF)
	{
	WavePlayerStop();
	RepeatState=;
	}


Si hago eso, cuando vuelva a presionar el botón de usuario, al estar
el CmdIndex en PLAY, el HAL GPIO lo va a pasar a STOP de nuevo
y no va a salir

Por lo tanto en el main, el case quedaría:

case CMD_STOP:
	if (RepeatState==REPEAT_ON)
	{
	WaveRecorderStop();}

	else if ((RepeatState==REPEAT_ON) && (AudioPlayStart==1)){
	WavePlayerStop();
	RepeatState=REPEAT_OFF;}
break;

Por lo tanto lo que voy a modificar son las lineas a partir de 484 de main.c

else if (CmdIndex == CMD_STOP)
{if (RepeatState==REPEAT_ON){
CmdIndex=CMD_PLAY;
}
else if (RepeatState==REPEAT_OFF)
{
CmdIndex=CMD_RECORD;
}
 
******************************************************************************
8-11-22

Hoy voy a probar lo que escribí antes, habiendo hecho un repaso general para 
no meter la pata. Si llega a funcionar todo como lo pensé, paso a cambiar
lo de los 30seg de grabación y rep automática.

No, no ví Memento porque no estaba en Netflix jajaj lol pero lo haré

En fin, prosigamos.


Primero, no sé porque las lineas están defasadas en 15. Osea a todo
lo que escribí antes le tengo que restar 15 para saber en que linea actual
estoy. Meh. Debí haber escrito algo y no me acuerdo.

Bien

tengo que copiar en el main.c el case de COMMAND_AudioExecuteApplication(void)
nuevo y modificar ek else if de stop de la interrupción .
Además debo modificar, dentro de la interrupción, para cada CmdIndex
el estado siguiente. Es decir, para CMD_RECORD y CMD_PLAYA, el estado
siguiente deberá ser CMD_STOP.

No hizo nada, funciona como al principio.
Me voy a fijar como terminan las variables dentro del wave recorder y play.
Modificaría la 180 PLAY y 211 PLAY de waverecorder a CMD_STOP;//lito

Cambio de waveplayer la linea 307, de CMD_RECORD a CMD_STOP.//esto lo volvi 
para atrás

FUNCIONA (Estaba mal acomodada una llave en el case tmb jeje)

Me fui a ser feliz. Bye.

Como quedó el main. c posta

static void COMMAND_AudioExecuteApplication(void)
{
  /* Execute the command switch the command index */
  switch (CmdIndex)
  {
    /* Start Playing from USB Flash memory */
  case CMD_PLAY:
    if (RepeatState == REPEAT_ON)
      WavePlayerStart();//es a lo primero que entra a porque cmdindex esta inicializado en play y repeat en on
    break;
    
    /*Agrego estas lineas para probar si se detiene cuando termino de grabar*/
//  case CMD_STOP:
	//  RepeatState = REPEAT_ON;
	 // WaveRecorderStop();
	  //WavePlayerStop();//esto tal vez no vaya
	  //break;

  case CMD_STOP:
  	if (RepeatState==REPEAT_ON)
  	{
  	WaveRecorderStop();
  	}

  	else if ((RepeatState==REPEAT_ON) && (AudioPlayStart==1)){
  	WavePlayerStop();
  	RepeatState = REPEAT_OFF;
  	}
  break;

    /* Start Recording in USB Flash memory */ 
  case CMD_RECORD:
    RepeatState = REPEAT_ON;
    WaveRecorderProcess();
    break;

  default:
    break;
  }

y en la interrupción

474 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) //EN QUE MOMENTO DE LA VIDA ENTRA A ESTA FUNCION?!
{
  if(GPIO_Pin == GPIO_PIN_0) 
  {
    if (PbPressCheck == 0)
    {
      HAL_Delay(10);

      /* Test on the command: Recording */
      if (CmdIndex == CMD_RECORD)
      {
        RepeatState = REPEAT_ON;
        //a partir de acá es donde creo que debería cambiar, porque no quiero que pase automaticamente al estado de repoducción
        /* Switch to Play command */
        CmdIndex = CMD_STOP;
      }
      /* Test on the command: Playing */
      else if (CmdIndex == CMD_PLAY)
      {
        /* Switch to Record command */
        CmdIndex = CMD_STOP;
      }
      /*else if (CmdIndex == CMD_STOP)
      {
        RepeatState = REPEAT_ON;//tal vez lo cambie
        // Default Command Index: Play command
        CmdIndex = CMD_PLAY;
      }*/

      else if (CmdIndex == CMD_STOP)
      {
    	  if (RepeatState==REPEAT_ON){
    		  CmdIndex=CMD_PLAY;
    	  }

		  else if (RepeatState==REPEAT_OFF){
			  CmdIndex=CMD_RECORD;
		  }
      }
      PbPressCheck = 1;
    }
    else
    {
      PbPressCheck = 0;
    }
  }
  
  if(GPIO_Pin == GPIO_PIN_1) 
  {
    if (PressCount == 1)//si es la segunda vez que se aprieta sería?
    {
      /* Resume playing Wave status */
      PauseResumeStatus = RESUME_STATUS;
      PressCount = 0;
    }
    else
    {
      /* Pause playing Wave status */
      PauseResumeStatus = PAUSE_STATUS;
      PressCount = 1;
    }
  }
536 } 


Lo unico que sigue funcionando asquerosamente es el rebote mal hecho del
pulsador. Pero no es mi culpa. Que conste.

Ahora sí, me fuí a buscar Memento por Cuevana jajaj


Cuando lo volví a hacer funcionar, se trababa en la repoducción
y luego de unos intentos se activa el led rojo.

Voy a probar crear una variable nueva en waveplayer y utilizar eso
para el condicional del case del main.c, exportando la variable
como externa.

_IO uint32_t Variable_de_estado = 0;

Lo dejé como estaba, sigue haciendo el mismo problema, no sé que cambió.
Desp lo veo.

**************************************************************************
10/11/22

Hoy con el profesor vimos un par de cosas.

Después de lograr que grabe-pare-reproduzca-pare y vuelva a arrancar,
tengo que mejorar el tema del rebote.

Como lo hacemos?

Utilizando la interrupción del SysTickHook, dentro de el voy a copiar
lo del control de estados y el gpio.
Hay que bloquear la interrupción por el botón de usuario
Hay que pasar como parametro igualado a cero el Button_mode_exti
dentro del BSP_pb_INIT

Después vamos a trabajar en el teclado matricial. Pero por ahora me 
concentro en lo de la interriupicuion

en main.c
L115 cambio BUTTON_MODE_EXTI por 0;

agrego en L22 #include "SysTick.h"

NO TIENE EN LA BIBLIOTECA EL SYSTICK.H, al cabo que ni quería. 

L28 agrego #define SYSTICK_FREQ_HZ 1000

***************************************************************************
17/11/22

Copie en la carpeta de scr el systick.c y en la de inc copie la
systick.h y commonio.h

Funcionó, ahora no me salta error cuando tiene que definir systick

en L 92 de main.c agregué SysTick_Init (SYSTICK_FREQ_HZ);

Lo que uso para el systickhook de los trabajos anteriores.

void SysTickHook (void) // Para colgarse del System Tick
{	static uint8_t contador=0, contador_f=0;

	// Control de SW1
	static uint8_t cambiar_estado, cambiar_estado_f;//reemplaza el while de gancho


	if((!HAL_GPIO_ReadPin (GPIOA, SW1))){
		contador++;

			if (!HAL_GPIO_ReadPin (GPIOA, SW1) && (contador==30) && (cambiar_estado)){
					cambiar_estado=0;
					modo_AUDIO = !modo_AUDIO;

					if(modo_AUDIO==PLAY){
					HAL_GPIO_WritePin(GPIOD, LED_ROJO_A, GPIO_PIN_RESET);
					HAL_GPIO_WritePin(GPIOD, LED_VERDE_A, GPIO_PIN_SET);
					}
					else{
						HAL_GPIO_WritePin(GPIOD, LED_ROJO_A, GPIO_PIN_SET);
						HAL_GPIO_WritePin(GPIOD, LED_VERDE_A, GPIO_PIN_RESET);
					}
					contador=0;

	}}
	else{
		cambiar_estado=1;

	}


******************************************************************************
18/11/22

Voy a sacar el HAL_Delay de HAL_GPIO_EXTI_Callback
Y voy a meter todo lo que está ahí, en el Systickhook.
Ademas tengo que crear las variables cambiar estado y contador.

Quedaría así:


void SysTickHook (uint16_t GPIO_Pin) // Para colgarse del System Tick
{static uint8_t contador=0; 
 static uint8_t cambiar_estado;

  if(GPIO_Pin == GPIO_PIN_0) 
  {contador++;
    if (PbPressCheck == 0)
    {
	if((GPIO_Pin == GPIO_PIN_0) && (contador==30) && (cambiar_estado)){
		cambiar_estado=0;

      /* Test on the command: Recording */
      if (CmdIndex == CMD_RECORD)
      {
        RepeatState = REPEAT_ON;
        //a partir de acá es donde creo que debería cambiar, porque no quiero que pase automaticamente al estado de repoducción
        /* Switch to Play command */
        CmdIndex = CMD_STOP;
      }
      /* Test on the command: Playing */
      else if (CmdIndex == CMD_PLAY)
      {
        /* Switch to Record command */
        CmdIndex = CMD_STOP;
      }

      else if (CmdIndex == CMD_STOP)
      {
    	  if (RepeatState==REPEAT_ON){
    		  CmdIndex=CMD_PLAY;
    	  }

		  else if (RepeatState==REPEAT_OFF){
			  CmdIndex=CMD_RECORD;
		  }
      }
      PbPressCheck = 1;
    }
	contador=0;
}
    else
    {
      PbPressCheck = 0;
    }
  }
  
  if(GPIO_Pin == GPIO_PIN_1) 
  {
    if (PressCount == 1)//si es la segunda vez que se aprieta sería?
    {
      /* Resume playing Wave status */
      PauseResumeStatus = RESUME_STATUS;
      PressCount = 0;
    }
    else
    {
      /* Pause playing Wave status */
      PauseResumeStatus = PAUSE_STATUS;
      PressCount = 1;
    }
  }
} 

*******************************************************************************
26/11/22

Comento de la linea 474 a la 536 del main.c para copiar la interrupción
del sistickhook

Agrego lineas de 537 a la 598 en el main.c

Cambio:

void SysTickHook (void) // Para colgarse del System Tick
{static uint8_t contador=0;
 static uint8_t cambiar_estado;
 uint16_t GPIO_Pin;

SysTick_Init (SYSTICK_FREQ_HZ);


Me tira error en la linea 92 del main.c por eso...

Agrego en stm32f4_discovery.c

lineas 188 a 194

/**
 * Creo una funcion vacia de sistick
 */

void SysTick_Init(uint16_t Frec_Ticks_Hz){
	SysTick_Config (SystemCoreClock / Frec_Ticks_Hz);
}

(SystemCoreClock
//If you use this function to configure the system clock; then there
               is no need to call the 2 first functions listed above, since SystemCoreClock
               variable is updated automatically.

y linea

38  #include "SysTick.h"

Puerbo

No funciona

Agrego lines 209 a 213 en stm32f4_discovery.c por las dudas

lo saco

Descomento lo de main.c y vuelvo a dejar la funcion de HAL
Comento lo de systickhook


Volví a dejar   BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI); 
despues debería volver a ponerlo en cero para usar el systick

Si, funciona como antes.

Lo vuelvo a poner en cero (linea 115)

Lo cambio de nuevo
Voy a ponerlo como BUTTON_MODE_GPIO para que lo configure como entrada 
pero no parahablitar la interrupcion
Y vuelvo a descomentar el systick y a comentar el HAL de main.c

no me reconoce el boton de usuario
Lo aprieto y no hace nada

Me tira errores en las variables que declaro dentro del SystickHook

Tanto para GPIO_Pin como para contador y cambiar_estado

Lo dejo así funcionando mal para verlo después.

*****************************************************************************
2/12/22

Voy a probar el programa de nuevo pero esta vez voy a sacar todo lo 
que puse antes y voy a dejarlo como cuando funcionaba.
Después voy a agregar el Systick pero con una función simple 
para saber si está entrando o no.

Es mas o menos lo mismo, pero así puedo guiarme mejor con qué es
lo que no funciona.

*****************************************************************************
6-12-22

Me fije si el systickInit estaba antes del Systic_Config,
Pero no, está después.

L82 comentada
L115 comentada
L82 descomento

Agrego linea 153 en stm32f4xx_it.c

la quito

comento linea 46 de stm32f4xx_it.c y linea 150-160
/void SysTick_Handler(void)
//{
//  HAL_IncTick();
//
//  /* Test on the command: Recording */
//  if (CmdIndex == CMD_RECORD)
//  {
//    /* Increments the time recording base variable */
//    TimeRecBase ++;
//  }
//}

*******************************************************************************
9/12/22

Seguí el camino del HAL_GPIO_EXTI_Callback y me dirije a stm32f4xx_hal_gpio.c
y despues a stm32f4xx_hal_gpio.h donde se declaran varias funciones.

Voy a pasarle como parametro a SystickHook el uint16_t GPIO_Pin
y copiar el llamado de la funcion en el ultimo archivo que
dije antes.


********************************************************************************
16/12/22

No toma el pin porque lo hacia en la interrupción
Así que tengo que volver a leer el pin como lo hacía antes
HAL_GPIO_PIN_ReadPin

18/12/22

Tengo que guardar la carpeta que me mando el profe en el src creo
Y desp fijarme como hacía para leerlo y a que pin corresponde el de 
usuario.
Una vez hecho eso, a pensar en la matriz.

El mapeao de la matriz se hace con un barrido por las salidas, sabiendo
que entrada se presionó.

Desp hago el pseudo código y lo paso a C.

ARGENTINA CAMPEON DEL MUNDO :D <3 <3 <3

*****************************************************************************
21/12/2022

Agrego en las lineas 117 y 118

  __HAL_RCC_GPIOC_CLK_ENABLE();
  In_Init(GPIOC, SEL_MUX_0);

linea 546  if(GPIO_Pin == GPIO_PIN_0)
la cambio por: (!HAL_GPIO_ReadPin (GPIOC, SEL_MUX_0))

Blue_button

creo que es así

In_Init(GPIOA, Blue_button, 1);
(!HAL_GPIO_ReadPin (GPIOA, Blue_button))

La linea 588 utiliza el GPIO_PIN_1 pero es del accelerometro, y en este
proyecto no lo utilizo.
Voy a ver si comentandolo lo puedo desestimar y seguir trabajando solo con 
el GPIO_PIN_0

Modiifique las otras lineas que tenian la lectura del GPIO_PIN_0
Y también comenté las lineas que evaluan el GPIO_PIN_1 porque
no lo uso creo.

Mañana lo pruebo.

***************************************************************************
21/12/2022

No funcionó

***************************************************************************

26/12/2022

Le hice un montón de modificaciones al código
Pero no me acuerdo cuales.
Se que si no inicializaba el cambio_estado y no ponia
la verificacion del contador en el if, entraba al segundo if.
Pero necesito esas variables.
Ahora voy a probar hasta donde ingresa.

Voy a dejar el SystickHook con una tarea simple.
Lo probe con prender y a pagar un led cada cierto tiempo y funcionó.
Voy a probar la lectura del bluebutton.

 if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 BSP_LED_Toggle(LED5);
 }

Con esa prueba el led se prende pero no queda encendido.
Voy a intentar apretar y que se quede prendido.
contador++;
 if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 BSP_LED_On(LED5);
 }
 if (contador==30000) {
	 BSP_LED_Off(LED5);
 }
con ese código, lo hace.

Ahora voy a agregar el contador como condición para el rebote.

cambiar_estado++;
 if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 contador++;
	 if (HAL_GPIO_ReadPin (GPIOA, Blue_button) && (contador==30)){
	 	 BSP_LED_On(LED5);
	 	 contador=0;
	 	 
	  }
 }
 if (cambiar_estado==20000) {
	 BSP_LED_Off(LED5);
	 cambiar_estado=0;
 }

Funciona. Tengo que tener cuidado donde vuelvo a hacer cero el contador
porque de otra manera puede no volver a entrar en el if.

Le agrego la condicion de cambiar estado.

 if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 contador++;
	 if (HAL_GPIO_ReadPin (GPIOA, Blue_button) && (contador==30)&& (cambiar_estado)){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
 }
 else {
	 cambiar_estado=1;
 }

Funciona, me había olvidado el último else.

Pero le agrego un if para apagar el led y la cago:

 if (tiempo==30000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
 }

Ahora con este codigo se apaga despues de 30 seg pero no lo puedo volver
a encender:

 if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 contador++;
	 if (HAL_GPIO_ReadPin (GPIOA, Blue_button) && (contador==30)&& (cambiar_estado)){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
 }
 else {
	 cambiar_estado=1;
 }
 if (estadoanterior==1){
	 tiempo++;
 if (tiempo==30000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
 }}

Si le comento el cambiar estado, puede volver a encenderse.


 if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 contador++;
	 if (HAL_GPIO_ReadPin (GPIOA, Blue_button) && (contador==30)/*&& (cambiar_estado)*/){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
 }
 else {if (!HAL_GPIO_ReadPin(GPIOA, Blue_button)){
	 cambiar_estado=1;
 }}
 if (estadoanterior==1){
	 tiempo++;
 if (tiempo==15000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
 }}
Así, funciona.

Lo probé en Pascal de la siguiente manera:

program Prueba_SysTickHook;

var
	op:char;
	contador: byte;
	ESTADO:string[50];
	
procedure SysTickHook (opcion:char;var contador:byte; var ESTADO: string);
var
	cambiar_estado: boolean;

begin
	cambiar_estado:=true;
	if (opcion='1') then
	begin
		contador:=contador+1;
		if ((opcion='1') and (contador=10) and (cambiar_estado)) then
		begin
			cambiar_estado:=false;
			writeln('Usted ha ingresado al triangulo de las bermudas jiji uwu');
			contador:=0;
			ESTADO:='LLEGUE';
		end;
	
	end
	else
	begin
		cambiar_estado:=true;
		writeln('Ya no es mas op 1');
	end;
end;


begin
	contador:=0;
	writeln('Ingrese opcion: F para terminar ');
	readln(op);
	while (op<>'F') do
	begin
		SysTickHook(op, contador, ESTADO);
		writeln('Ingrese la opcion 1 para contar: ');
		readln(op);
	end;
end.


Puede ser que no tome cambiar_estado como TRue para el booleano al '1'.
Otra cosa no se me ocurre.

Lo voy a dejar así y volver a probar el programa de grabacion.que no reacciona al pinche boton

 
Ahora voy a seguir el diagrama de flujo de repoducción y grabación del
programa.
Luego verificaré las condiciones de los if.

*********************************************************************************
30/12/22

Hemos descubierto americaaaaaaa
Faltaba arreglar las condiciones de los if jiji

void SysTickHook (void) // Para colgarse del System Tick

{
 static uint32_t contador=0;
 static uint32_t cambiar_estado;//si no lo inicializo, no entra al segundo if. con el else se solucionaria.
static uint32_t tiempo=0;
static uint32_t estadoanterior;

if (HAL_GPIO_ReadPin (GPIOA, Blue_button)){
	 contador++;
	 if (HAL_GPIO_ReadPin (GPIOA, Blue_button) && (contador>=30) && (cambiar_estado==1)){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
}
else {if (!HAL_GPIO_ReadPin(GPIOA, Blue_button)){
	 cambiar_estado=1;
}}
if (estadoanterior==1){
	 tiempo++;
if (tiempo==15000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
}}
}

Se que es la prueba del led nomás, pero funciona. Dada esta situación, voy a dejar
acá porque una campeona sabe cuando retirarse, y más tarde lo pruebo con lo
de la grabación.
bye
******************************************************************************************
3/1/23

Hoy voy a probar el de audio.
Cambio lo del if con contador contador>=30 y puse el contador=0 dentro del 
segundo if como en la pruebita del led anterior.

guardo esto por aquí por si las dudas. Es lo que había antes de utilizar
el SysTickHook

//void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) //EN QUE MOMENTO DE LA VIDA ENTRA A ESTA FUNCION?! era una interrupcion al final
//{
//  if(GPIO_Pin == GPIO_PIN_0)
//  {
//    if (PbPressCheck == 0)
//    {
//      HAL_Delay(10);
//
//      /* Test on the command: Recording */
//      if (CmdIndex == CMD_RECORD)
//      {
//        RepeatState = REPEAT_ON;
//        //a partir de acá es donde creo que debería cambiar, porque no quiero que pase automaticamente al estado de repoducción
//        /* Switch to Play command */
//        CmdIndex = CMD_STOP;
//      }
//      /* Test on the command: Playing */
//      else if (CmdIndex == CMD_PLAY)
//      {
//        /* Switch to Record command */
//        CmdIndex = CMD_STOP;
//      }
//      /*else if (CmdIndex == CMD_STOP)
//      {
//        RepeatState = REPEAT_ON;//tal vez lo cambie
//        // Default Command Index: Play command
//        CmdIndex = CMD_PLAY;
//      }*/
//
//      else if (CmdIndex == CMD_STOP)
//      {
//    	  if (RepeatState==REPEAT_ON){
//    		  CmdIndex=CMD_PLAY;
//    	  }
//
//		  else if (RepeatState==REPEAT_OFF){
//			  CmdIndex=CMD_RECORD;
//		  }
//      }
//      PbPressCheck = 1;
//    }
//    else
//    {
//      PbPressCheck = 0;
//    }
//  }
//
//  if(GPIO_Pin == GPIO_PIN_1)
//  {
//    if (PressCount == 1)//si es la segunda vez que se aprieta sería?
//    {
//      /* Resume playing Wave status */
//      PauseResumeStatus = RESUME_STATUS;
//      PressCount = 0;
//    }
//    else
//    {
//      /* Pause playing Wave status */
//      PauseResumeStatus = PAUSE_STATUS;
//      PressCount = 1;
//    }
//  }
//}

en CommonIO.h puse
#define Reset_button GPIO_PIN_1

nop, no funciono

*********************************************************************************
4/1/23

        AudioRemSize -= bytesread;//si bytesread siempre es cero como hace para disminuir AudioRemSize?

I think that is the problem here is that the the program remains in the wild 
psycho while psycho OK not it's not psycho it's psycho but whatever and and 
I think that the problem is the microphone that doesn't work like it has it 
helps and maybe if I prove with other board Umm this will work I don't know
because I already see the main see and the main dot C on the main dot H and 
the word player.tv and there was nothing wrong there so on in the functions 
of F dot C neither I find the problem so what I think is that the problem is 
in the board not in my code and then the bones of the user switch the user 
bottom and works perfectly and now I have to see if I can manage the for a 
matrix for the final application and that's all the the final task for me 
let's see if I can change the names of the files when they record into the 
USB memory and hey use each file for each bottom and get the access to 
the each bottom to the each file and but that that is what makes the function 
of F8 and F record in the F dot C so maybe just calling the function I can use 
the configuration of of so where is 5 so not five files so yes I think that's 
all thank you.

Activé el dictado por voz porque me aburre escribir tanto. Y tosdavía no
tengo descargado el idioma español así que lo hice en Inglés. Por eso
lo horrible al leerlo jojo.

I will see if there's something wrong in the USB memory. 
And I record an audio with high volumes of voice and now I will see what 
is what the program. write in the text so maybe there's something wrong 
with the volume of recording i don't know maybe it's that i don't know.

So I opened the breakfield. And. No. Redfield is. The wreck. File. 
Is not working. Anyway, I openness the file in the the recording, 
it's perfect when I. Reproduce. When I played the, the file sounds 
perfect in the. Windows. Player. But not in the other hand. There's 
not. There's something something wrong with the board and the. The way 
player. But I don't know what it is. Maybe I can see the? I wish to know 
how to convert the the the file that way. Into numbers like the samples, 
then the number of the samples with some program in MATLAB, but right now 
I don't know how to do that and I don't have Matlab, I just have octave 
it and it works. Awful. So. That's all. Umm. Definitely the problem is 
on the way play. That's something good, or maybe not bad, just the 
problem is just in one place. There's no the problem, it's not on the 
main dot C. And. Neither in the wave recorded duty. So dot C not daddy. 
And so that I don't know. I already. Searching the. For player and there's 
nothing wrong. I don't know. Certainly how it works today. The the error. 
Of the file when? When it's when the problem program is. Reading the file.
And there's a. Mistake. There's a error. I don't know how that. 
Goes to remain. See. I don't know what is the variable that you use. 
But. Yeah, I don't know. For me it's a problem of the microphone. 
Maybe if I search in the Internet I will. I'm sure that someone happened 
the same thing, so I mean we will. Look for that.

ᩀ ૞ᤀ>> [Y, FS] = audioread ('D:\rec.wav')
Use esto para ver las muestras del audio pero no veo nada raro.

Al final lo que estaba molestando para la reproduccion era el volumen de 
reproducción. Lo baje a 70% y funcionó sin problemas. 

*********************************************************************************
6/01/23

Inicializo SW1 con   In_Init(GPIOA, SW1, 1);
Osea que pongo un pull up en la entrada SW1 para que cuando aprete el boton 
en la salida tenga un cero y cuando no, tenga un uno.
Pero me lo está leyendo al revés. Si pongo HAL_GPIO_ReadPin (GPIOA, SW1)
Sin negarlo, me lo toma bien. Es decir que hay un 1 lógico en la entrada cuando 
lo aprieto. Cuando debería ser lo contrario.

No se que pedos, me lo lee con !HAL_GPIO_ReadPin y con HAL_GPIO_ReadPin.

void SysTickHook (void) // Para colgarse del System Tick

{
 static uint32_t contador=0;
 static uint32_t cambiar_estado;
static uint32_t tiempo=0;
static uint32_t estadoanterior;

if ((!HAL_GPIO_ReadPin (GPIOA, SW1))){
	 contador++;
	 if ((!HAL_GPIO_ReadPin (GPIOA, SW1)) && (contador>=30) && (cambiar_estado==1)){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
}
else {
	 cambiar_estado=1;
}
if (estadoanterior==1){
	 tiempo++;
if (tiempo==15000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
}}
}

Debería andar medio medio el cable. Pero no tendría que tomarme el boton
si le pregunto si esta en alto cuando lo apreto. Sospechoso.

Prueba de toda la matriz

void SysTickHook (void) // Para colgarse del System Tick

{
 static uint32_t contador=0;
 static uint32_t cambiar_estado;
static uint32_t tiempo=0;
static uint32_t estadoanterior;

if ((!HAL_GPIO_ReadPin (GPIOA, SW1)) || (!HAL_GPIO_ReadPin (GPIOA, SW2)) || (!HAL_GPIO_ReadPin (GPIOA, SW3))){
	 contador++;
	 if (((!HAL_GPIO_ReadPin (GPIOA, SW1)) || (!HAL_GPIO_ReadPin (GPIOA, SW2)) || (!HAL_GPIO_ReadPin (GPIOA, SW3))) && (contador>=30) && (cambiar_estado==1)){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
}
else {
	 cambiar_estado=1;
}
if (estadoanterior==1){
	 tiempo++;
if (tiempo==15000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
}}
}

Funcionó
*********************************************************************************
8/01/23

__HAL_RCC_GPIOD_CLK_ENABLE();
In_Init(GPIOD, GPIO_PIN_15, 1);//FILA_1
Out_Init(GPIOD, GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_9|GPIO_PIN_13 , 0);//configuracion de 4 salidas

HECHOO


if ((!HAL_GPIO_ReadPin (GPIOA, SW1))&&(!HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_8))){
	 contador++;
	 if ((!HAL_GPIO_ReadPin (GPIOA, SW1)) && (!HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_8)) && (contador>=30) && (cambiar_estado==1)){//el cambiar estado lo que hace es permitirme mantener apretado el botón sin que se salga del estado en el que está. Recién puede entrar a otro estado cuando suelto el botón.
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	  }
}
else {
	 cambiar_estado=1;
}

if (estadoanterior==1){
	 tiempo++;
if (tiempo==1000) {
	 BSP_LED_Off(LED5);
	 tiempo=0;
	 estadoanterior=0;
}}
No identifica las filas...
Creo que tengo que modificar algo desde la lectura dentro del programa

*****************************************************************************************
10/01/23

Bueno, lo que pensé es que como todas las salidas estan conectadas a masa,
claramente cuando aprete una fila distinta a la que estoy preguntando
va a tomar como que sí estoy presionando esa. Pero en realidad no. Pero dice
que si porque estan todas a masa.
Entonces lo que pensé es en desconectar las salidas de masa y solamente
llevarlas a la placa discovery. De ahí le pregunto en el programa
si la entrada es igual a la salida. Y listo.
Para hacerlo más prolijo ppodría plantear una matriz con todas las
posibles conexiones y despues con coordenadas preguntar si se da una o la otra.

*********************************************************************************
12/01/23

Lista de pines para filas y columnas:(Cambie la configuracion de la columna 2 y 3)

COLUMNA_1: SW1(PA2) COLUMNA_2:SW2(PA4) COLUMNA_3:SW(PA5) COLUMNA_4:GPIO_PIN_15(PD15)

FILA_1: PD8 FILA_2: PD9 FILA_3: PD11 FILA_4: PD13


S1: SW1 && GPIO_PIN_8;
S2: SW2 && GPIO_PIN_8;
S3: SW3 && GPIO_PIN_8;
S4: GPIO_PIN_15 && GPIO_PIN_8;

S5: SW1 && GPIO_PIN_9;
S6: SW2 && GPIO_PIN_9;
S7: SW3 && GPIO_PIN_9;
S8: GPIO_PIN_15 && GPIO_PIN_9;

S9: SW1 && GPIO_PIN_11;
S10:SW2 && GPIO_PIN_11;
S11:SW3 && GPIO_PIN_11;
S12:GPIO_PIN_15 && GPIO_PIN_11;

S13:SW1 && GPIO_PIN_13;
S14:SW2 && GPIO_PIN_13;
S15:SW3 && GPIO_PIN_13;
S16:GPIO_PIN_15 && GPIO_PIN_13;

Puedo crear una varible que sea OP y tome valores como S1, S2, etc...

If (HAL_GPIO_ReadPin (GPIOA, SW1) == GPIO_PIN_8) {
	contador++;
	if((HAL_GPIO_ReadPin (GPIOA, SW1) == GPIO_PIN_8) && (contador>=30) && (cambiar_estado==1)){
		 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;
	}
}

***********************************************************************
18/01/23

No funciono

Quiero que a cada salida se le asigne un valor unico a traves
de una varible, supongo. Entonces si la entrada pirulo es igual
a ese valor de esa variable es porque se refiere a esa salida.
Se entiende?

***************************************************************************************
28/01/23

Cuando apriete, una variable va a tomar el valor de lo que esté
dentro de la matriz en esa ubicación y después con un case le
digo si es S1 hace tal cosa, si es S11 hace tal otra, y así.

 #define FILA_1		 GPIO_PIN_8
 #define FILA_2 		 GPIO_PIN_9
 #define FILA_3 		 GPIO_PIN_11
 #define FILA_4 		 GPIO_PIN_13
 #define COLUMNA_1	 GPIO_PIN_2
 #define COLUMNA_2	 GPIO_PIN_4
 #define COLUMNA_3	 GPIO_PIN_5
 #define COLUMNA_4	 GPIO_PIN_15

Primero defino las columnas y filas

Después
In_Init(GPIOA, COLUMNA_1|COLUMNA_2|COLUMNA_3, 1);
In_Init(GPIOD, COLUMNA_4, 1);
Out_Init(GPIOD, FILA_1|FILA_2|FILA_3|FILA_4 , 0);

MATRIZ

string switches[4][4]={{'S1','S2','S3','S4'},
			     {'S5','S6','S7','S8'},
			     {'S9','S10','S11','S12'},
			     {'S13','S14','S15','S16'}};

CREO QUE ASÍ SE CREA LA MATRIZ

Uh dejé el May heheh
Bueno, la idea era asignarle a cada entrada un valor constante
Ej: C1:=1, C2:=2, C3:=3, C4:=4;

Así cuando pregunte a la salida de las filas, en lugar de leer masa
debería leer alguna de esas constantes.

Entonces:

HAL_GPIO_WritePin(GPIOA, COLUMNA_1, );

Aaaahhhhhhh nooooo
Porque así tendría que declarar una varible que tome el pin que corresponde
pero no se como asignarle a una variable GPIO_PIN2 por ej.
Entonces lo que si puedo hacer es lo mismo pero de otra manera:

A lo que le voy a definir un estado (valor de constante) va a ser
a las filas que son las salidas.(Re que siempre iba a asignarle valores
a la salida, no se porqué lo cambie jeje)

En fin, cada salida va a poder tomar el valor de SET o RESET.

Como son solo dos valores y necesito diferenciar cuatro columnas,
2^2=4 estados.

Para la fila 1:

HAL_GPIO_WritePin(GPIOA, FILA_1, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, FILA_2, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, FILA_3, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, FILA_4, GPIO_PIN_SET);

Para fila 2:

HAL_GPIO_WritePin(GPIOA, FILA_1, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, FILA_2, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, FILA_3, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, FILA_4, GPIO_PIN_SET);

Para fila 3:

HAL_GPIO_WritePin(GPIOA, FILA_1, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, FILA_2, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, FILA_3, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, FILA_4, GPIO_PIN_SET);

Para fila 4:

HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_RESET);


Entonces pregunto 
if (fila)

Ah y ahora como pregunto?

Si pongo todo eso de una, en el medio tendría que ir preguntando que columna
está en bajo. Osea:

Por ej debajo de la fila 1:

if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_1)){switch='S1'};
if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_2)){switch='S5'};
if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_3)){switch='S9'};
if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)){switch='S13'};

switch sí sería una variable tipo string que toma su valor en ese if.

Desp quedaría preguntar con un case:
Si switch es 'S1': blah blah
Si switch es 'S2': blah blah

con blah blah me refiero a grabar y reproducir todo en un mismo archivo
Despues le asigno a cada boton un archivo distinto.

Y el nombre de la variable no va a poder ser switch porque creo que es una
palabra reservada así que la cambio a boton jeje.

AHORA, está bien? No lo sé. Tengo que probarlo pero ya es algo.
Y todo lo pondria en el systickhook, lo que me da un poco de sarna
que se llene de tantas cosas.
Tal vez podría crear una funcion aparte para llamarla y que no quede
tan engorroso.
Desp veo eso.
Lo otro que iba a decir es.... ah! lo del rebote!!! Que temita.

No solo tendría que preguntar !HAL_GPIO blah blah, sino que debería
crear tres variables mas de contador, cambiar_estado y estadoanterior,
para poder  diferenciar de cada uno, o no?

Y preguntar !HAL_GPIO blahblah, desp contador++ y contador>=30=? y 
cambiar_estado==1?


Ah lo de estadoanterior lo usaba para una prueba mia de led, no es necesaria
para lo de grabar y reproducir :)


Y así.
Se entiende?
Un bardo la verdad.

*********************************************************************************************

29/01/23

La cuestión quedaría así entonces:

void SysTickHook (void) // Para colgarse del System Tick

{
 static uint32_t contador=0;
 static uint32_t cambiar_estado;
 string boton='N'; 

 HAL_GPIO_WritePin(GPIOA, FILA_1, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOA, FILA_2, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOA, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOA, FILA_4, GPIO_PIN_SET);


if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_1))
{
	contador++;
	if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_1) && (contador>=30) && (cambiar_estado==1)){
		boton=switches[0][0];
		cambiar_estado=0;
		Estados();
		contador=0;
    	}
} //{boton='S1'};



else if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_2))
{
	contador++;
	if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_2) && (contador>=30) && (cambiar_estado==1)){
		boton=switches[0][1];
		cambiar_estado=0;
		Estados();
		contador=0;
    	}

 } //{boton='S5'};


else if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_3))
{
	contador++;
	if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_3) && (contador>=30) && (cambiar_estado==1)){
		boton=switches[0][2];
		cambiar_estado=0;
		Estados();
		contador=0;
    	}

 } //{boton='S9'};



boton='S9'};
else if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_4))
{
	contador++;
	if (!HAL_GPIO_ReadPin(GPIOD, COLUMNA_4) && (contador>=30) && (cambiar_estado==1)){
		boton=switches[0][2];
		cambiar_estado=0;
		Estados();
		contador=0;
    	}

 } //{boton='S13'};



 else{
 		cambiar_estado=1;

 	}







switch(boton) {
case '1': 	 cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;

		
		if (estadoanterior==1){
	 		tiempo++;
		if (tiempo==1000) {
		 	BSP_LED_Off(LED5);
		 	tiempo=0;
		 	estadoanterior=0;
		}}
		
break;
case '5':    cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;

		if (estadoanterior==1){
	 		tiempo++;
		if (tiempo==5000) {
		 	BSP_LED_Off(LED5);
		 	tiempo=0;
		 	estadoanterior=0;
		}}
		
break;
case '9':    cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;

		if (estadoanterior==1){
	 		tiempo++;
		if (tiempo==9000) {
		 	BSP_LED_Off(LED5);
		 	tiempo=0;
		 	estadoanterior=0;
		}}
break;
case '@':  cambiar_estado=0;
		 BSP_LED_On(LED5);
	 	 contador=0;
	 	 estadoanterior=1;

		if (estadoanterior==1){
	 		tiempo++;
		if (tiempo==13000) {
		 	BSP_LED_Off(LED5);
		 	tiempo=0;
		 	estadoanterior=0;
		}}
break;

}


void Estados(void){
 	switch(boton) {
 	case '1': 	 cambiar_estado=0;
 			 BSP_LED_On(LED5);
 		 	 contador=0;
 		 	 estadoanterior=1;


 			if (estadoanterior==1){
 		 		tiempo++;
 			if (tiempo==1000) {
 			 	BSP_LED_Off(LED5);
 			 	tiempo=0;
 			 	estadoanterior=0;
 			}}

 	break;
 	case '5':    cambiar_estado=0;
 			 BSP_LED_On(LED5);
 		 	 contador=0;
 		 	 estadoanterior=1;

 			if (estadoanterior==1){
 		 		tiempo++;
 			if (tiempo==5000) {
 			 	BSP_LED_Off(LED5);
 			 	tiempo=0;
 			 	estadoanterior=0;
 			}}

 	break;
 	case '9':    cambiar_estado=0;
 			 BSP_LED_On(LED5);
 		 	 contador=0;
 		 	 estadoanterior=1;

 			if (estadoanterior==1){
 		 		tiempo++;
 			if (tiempo==9000) {
 			 	BSP_LED_Off(LED5);
 			 	tiempo=0;
 			 	estadoanterior=0;
 			}}
 	break;
 	case '@':  cambiar_estado=0;
 			 BSP_LED_On(LED5);
 		 	 contador=0;
 		 	 estadoanterior=1;

 			if (estadoanterior==1){
 		 		tiempo++;
 			if (tiempo==13000) {
 			 	BSP_LED_Off(LED5);
 			 	tiempo=0;
 			 	estadoanterior=0;
 			}}
 	break;

 	}




Funcion para controlar los estados cmdindex y repeatstate:

static void Estados (void){

	if (CmdIndex == CMD_RECORD)
      	{
       		 RepeatState = REPEAT_ON;
       	 	CmdIndex = CMD_STOP;
      	}

     		else if (CmdIndex == CMD_PLAY)
      	{
       		 CmdIndex = CMD_STOP;
        		 RepeatState = REPEAT_OFF;
     		}

     		else if (CmdIndex == CMD_STOP)
      	{
    	  		if (RepeatState==REPEAT_ON){
    		  		CmdIndex=CMD_PLAY;
    		  		BSP_LED_Off(LED5);
    	  		}

		  	else if (RepeatState==REPEAT_OFF){
				CmdIndex=CMD_RECORD;
			  	BSP_LED_On(LED5);
		  	}
      	}
	
}
  
************************************************************************************
01/02/23

Funciono esto


 HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_SET);

 if (HAL_GPIO_ReadPin(GPIOA, FILA_1)==0){
 	BSP_LED_On(LED5);
 }

if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
	BSP_LED_On(LED4);
}

Ahora a probar todos los botones y desp hacer mas eficiente

Funciona lo de comprobar el rebote, solo que tendría que crear
16 variables más para los distintos contadores. Ver eso que onda.

Desp, me parece el cuete lo de la matriz y lo del case.
Tipo, que directamente haga lo que tiene que hacer en la carpeta que le 
corresponde.

Lo que sí tal vez haría sería:
Crear una funcion dentro del SysTickHoook
Que haga lo de los estados de grabacion y reproducción.

Y que tenga como parametro alguna variable que le permita
elegir la carpeta donde va a guardar todo.

Me explico?

O no. No sé. Está heavy esa parte.

Creo que se me va a hacer muy largo el progrma

Pero bueno, mientras funcione, todo bien.

Saionara
************************************************************************************
03/02/2023

void SysTickHook (void) // Para colgarse del System Tick

{
 static uint32_t contador=0, contador_2=0, contador_3=0, contador_4=0, contador_5=0, contador_6=0, contador_7=0, contador_8=0;
 static uint32_t contador_9=0, contador_10=0, contador_11=0, contador_12=0, contador_13=0, contador_14=0, contador_15=0;
 static uint32_t contador_16=0;
 static uint32_t cambiar_estado;
 //char boton;
 //static uint32_t estadoanterior;


 HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_SET);

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
		contador++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador=0;

			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0){
		contador_2++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0) && (contador_2>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_2=0;
			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0){
			contador_3++;
			if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0) && (contador_3>=30) && (cambiar_estado==1)){
				cambiar_estado=0;
				BSP_LED_On(LED4);
			 	contador_3=0;

				}
		}


	else if (HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0){
				contador_4++;
				if ((HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0) && (contador_4>=30) && (cambiar_estado==1)){
					cambiar_estado=0;
					BSP_LED_On(LED4);
				 	contador_4=0;

					}
			}

	else{
			cambiar_estado=1;
		}

 HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_SET);

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
		contador_5++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador_5>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_5=0;

			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0){
		contador_6++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0) && (contador_6>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_6=0;
			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0){
			contador_7++;
			if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0) && (contador_7>=30) && (cambiar_estado==1)){
				cambiar_estado=0;
				BSP_LED_On(LED4);
			 	contador_7=0;

				}
		}


	else if (HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0){
				contador_8++;
				if ((HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0) && (contador_8>=30) && (cambiar_estado==1)){
					cambiar_estado=0;
					BSP_LED_On(LED4);
				 	contador_8=0;

					}
			}

	else{
			cambiar_estado=1;
		}

 HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_SET);

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
		contador_9++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador_9>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_9=0;

			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0){
		contador_10++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0) && (contador_10>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_10=0;
			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0){
			contador_11++;
			if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0) && (contador_11>=30) && (cambiar_estado==1)){
				cambiar_estado=0;
				BSP_LED_On(LED4);
			 	contador_11=0;

				}
		}


	else if (HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0){
				contador_12++;
				if ((HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0) && (contador_12>=30) && (cambiar_estado==1)){
					cambiar_estado=0;
					BSP_LED_On(LED4);
				 	contador_12=0;

					}
			}

	else{
			cambiar_estado=1;
		}

 HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_RESET);

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
		contador_13++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador_13>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_13=0;

			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0){
		contador_14++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0) && (contador_14>=30) && (cambiar_estado==1)){
			cambiar_estado=0;
			BSP_LED_On(LED4);
		 	contador_14=0;
			}
	}

	else if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0){
			contador_15++;
			if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0) && (contador_15>=30) && (cambiar_estado==1)){
				cambiar_estado=0;
				BSP_LED_On(LED4);
			 	contador_15=0;

				}
		}


	else if (HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0){
				contador_16++;
				if ((HAL_GPIO_ReadPin(GPIOD, COLUMNA_4)==0) && (contador_16>=30) && (cambiar_estado==1)){
					cambiar_estado=0;
					BSP_LED_On(LED4);
				 	contador_16=0;

					}
			}

	else{
			cambiar_estado=1;
		}


}

Eso usé para probar los botones y el rebote. Funca todo.
Ahora a ver si graba bien.


Graba, para, reproduce y se queda ahí o cuando termina se va a STOP y
también se queda ahí.

Estoy cansada pues 3.30am. Mañana veo de nuevo en que metí la pata
PUES ANTES FUNCIONABA PERFECTO.

Y desp me dedicaré a replicar eso para todos los botones
y a seleccionar una carpeta distinta para cada grabación.

Chau

*****************************************************************************
3/2/23

#define CMD_PLAY           ((uint32_t)0x00)
#define CMD_RECORD         ((uint32_t)0x01)
#define CMD_STOP           ((uint32_t)0x02)
#define CMD_STOPP		   ((uint32_t)0x03)
#define CMD_STOPR		   ((uint32_t)0x04)

Creé dos variables nuevas porque me cansé jojo

static void COMMAND_AudioExecuteApplication(void)
{
  /* Execute the command switch the command index */
  switch (CmdIndex)
  {
    /* Start Playing from USB Flash memory */
  case CMD_PLAY:
    if (RepeatState == REPEAT_ON)
      WavePlayerStart();//es a lo primero que entra a porque cmdindex esta inicializado en play y repeat en on
    break;
    
  case CMD_STOP:
  	if (RepeatState==REPEAT_ON)
  	{
  	WaveRecorderStop();
  	}

  	else if ((RepeatState==REPEAT_ON) && (Variable_de_estado==1)){
  	WavePlayerStop();
  	RepeatState = REPEAT_OFF;
  	}
  break;

    /* Start Recording in USB Flash memory */ 
  case CMD_RECORD:
    RepeatState = REPEAT_ON;
    WaveRecorderProcess();
    break;

  default:3333
    break;
  }
}

********************************************************************
4/02/2023

COLUMNA_1: SW1(PA2) COLUMNA_2:SW2(PA4) COLUMNA_3:SW(PA5) COLUMNA_4:GPIO_PIN_14(PD14)

FILA_1: PD8 FILA_2: PD9 FILA_3: PD11 FILA_4: PD13


************************************************************************************
25/02/23

Si voy a hacer entrar en dos estados distintos uno para grabar y otro para 
resproducir, y en la reproducción quiero que se puedan apretar dos
botones a la vez, entonces tengo que sacar en un if la condicion de
cambiar_estado.

Ahora volví a probar lo de la lectura de la matriz con este código para probar 
si distinguía bien entre filas y las columnas. Lo cual hace. Así que voy a 
pasarlo a lo de grabacion.

 HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_SET);

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
		contador++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador>=30) && (cambiar_estado==1)){
			cambiar_estado=0;


		 	 contador=0;
		 	 estadoanterior=1;

	}}
	else {
		 cambiar_estado=1;
	}

	if (estadoanterior==1){
		 tiempo++;
		 BSP_LED_On(LED6);
	if (tiempo==1000) {
		 BSP_LED_Off(LED6);
		 tiempo=0;
		 estadoanterior=0;
	}}


	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0){
		contador_2++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_2)==0) && (contador_2>=30) && (cambiar_estado==1)){
			cambiar_estado=0;


		 	 contador_2=0;
		 	 estadoanterior_2=1;

	}}
	else {
		 cambiar_estado=1;
	}

	if (estadoanterior_2==1){
		 tiempo_2++;
		 BSP_LED_On(LED6);
	if (tiempo_2==2000) {
		 BSP_LED_Off(LED6);
		 tiempo_2=0;
		 estadoanterior_2=0;
	}}

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0){
		contador_3++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)==0) && (contador_3>=30) && (cambiar_estado==1)){
			cambiar_estado=0;


		 	 contador_3=0;
		 	 estadoanterior_3=1;

	}}
	else {
		 cambiar_estado=1;
	}

	if (estadoanterior_3==1){
		 tiempo_3++;
		 BSP_LED_On(LED6);
	if (tiempo_3==3000) {
		 BSP_LED_Off(LED6);
		 tiempo_3=0;
		 estadoanterior_3=0;
	}}

HAL_GPIO_WritePin(GPIOD, FILA_1, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_2, GPIO_PIN_RESET);
 HAL_GPIO_WritePin(GPIOD, FILA_3, GPIO_PIN_SET);
 HAL_GPIO_WritePin(GPIOD, FILA_4, GPIO_PIN_SET);

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0){
		contador++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador>=30) && (cambiar_estado==1)){
			cambiar_estado=0;


		 	 contador=0;
		 	 estadoanterior=2;

	}}
	else {
		 cambiar_estado=1;
	}

	if (estadoanterior==2){
		 tiempo++;
		 BSP_LED_On(LED6);
	if (tiempo==5000) {
		 BSP_LED_Off(LED6);
		 tiempo=0;
		 estadoanterior=0;
	}}


 #define COLUMNA_4	 GPIO_PIN_14 //cambiar

 In_Init(GPIOA, COLUMNA_1|COLUMNA_2|COLUMNA_3, 1);
  In_Init(GPIOD, COLUMNA_4, 1);
  Out_Init(GPIOD, FILA_1|FILA_2|FILA_3|FILA_4 , 0);


PD14

BUEEEENO

Tengo problemas con la columna 4, así que no la voy a utilizar.

Voy a probar las otras dos filas y luego si paso a grabar

Sip, funcionan las cuatro filas
El unico problema es la columna 4.

Trabajaré solo con eso.

AVERRRRRRR



Los controles para grabar y respoducir andan mal
Cuando termina de reproducir todo 
que encima no se escucha nada
no va al stop

y hay como mucho rebote pero no creo que sea algo de
los pulasodres
Sino mas bien
que estan tomando varios valores al mismo tiempo los
CmdIndex y RepeatState

Bueno, anduvo perfecto col boton S1
sin rebotes

pruebo con el S2

Se buguea MAL

Voy a probar asignandole otro archivo al pulsador S2

Cambie esto en waverecorder.c

 /* Remove Wave file if it exists on USB Flash Disk *///Esto en realidad no quiero que lo haga
  //f_unlink (REC_WAVE_NAME);//esto no estaba comentado antes
  
  /* Open the file to write on it */
  if ((AppliState == APPLICATION_IDLE) || (f_open(&WavFile, REC_WAVE_NAME_1//acá le agregue el _1//, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK))
  {   


reproduccion en waveplayer

  */
void WavePlayerStart(void)
{
  UINT bytesread = 0; //cantidad de bytes leidos
  char path[] = "1:/"; //archivo de lectura esto era 0:// lo volví a dejar así


y dos lineas + abajo esto
  /* Get the read out protection status */
  if(f_opendir(&Directory, path) == FR_OK)
  {
    if(WaveRecStatus == 1)
    {
      wavefilename = REC_WAVE_NAME_1;
    }
    else


Bueno

Hay una funcion que me borra la grabacion anterior
Y no es f_unlink porqu eesa la comente y lo hizo igual

A no ser que haya sido por sobreescribir en la 
direccion de punteo 0://
Puede ser

La cuestion es que sigue bugueandose.

Voy a sacar lo del boton S2

Me quedo solo con S1 y veo como hacer para grabar distintos 
archivos sin tener que ir modificando los nombres en
waveplayer y waverecorder

**********************************************************************************************************
26/02/23

El problema está en que si aprieto el S1 por ejemplo empieza a grabar
y CmdIndex se pone en CMD_RECORD. Ahora si aprieto el S2 va a pasar a 
CMD_SOTP. No va a empezar a grabar el segundo sonido.

Por esto mismo, voy a crear dos estados
Uno se activa presionando S1 y S3 al mismo tiempo. GRABACIÓN
Una vez que entre a este estado, no tiene que salir a no se 
que se active el otro estado.

Una vez logrado eso, leo cada boton.
Si por ejemplo presiono el 1, se pasa el nombre 1:// rec_01.wav
como parametro a waverecorder, para que lo guarde ahí.

Si vuelvo a presionar tiene que quedarse en STOP del trcord.

Eso es todo lo que tiene que hacer este primer estado. Para
todos los pulsadores lo mismo.


Otro se activa presionando S11 y S15. REPRODUCCIÓN.
Ahora también el programa debe quedar en esa connfiguración de estado.
Por lo que no puede salir.

Presiono 3 y se pasa como parametro a waveplayer, el nombre
del archivo que corresponde al pulsador 3. 

Si vuelvo a apretar queda en STOP de play.//puedo agregar un contador para esto

Me acabo de dar cuenta que la columna 4 si funciona bien, el tema es que no le cambiaba el puerto
GPIO al que estaba asignado. Como C1, C2 y C3 son de GPIOA y C4 de GPIOD, copié y pegué
y la manquee.

Voy a crear una variable de tipo string que pueda tomar distintas constantes

#define grabando 1;
#define reproduciendo 2;
#define parado 3;

static estado_de_audio uint_32;

char NOMBRE[11];

if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3))){
		contador++;
		if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (HAL_GPIO_ReadPin(GPIOA, COLUMNA_3)) && (contador==80) && (cambiar_estado==1)){
		
		estado_de_audio=grabando;
		}}
	
while (estado_de_audio==grabando){//esto seguro lo tenga que cambiar a if's porque no está bien tener ciclos en el systick

	if (HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) {
	contador_1++;
	
	if ((HAL_GPIO_ReadPin(GPIOA, COLUMNA_1)==0) && (contador==80) && (cambiar_estado==1)){
		NOMBRE="1:rec_01.wav"
		
	}
	}
}

algo así
Despues en la parte de arriba tendría que llamar a 
WaveRecorderProcess(NOMBRE);
